#! /usr/bin/perl
use warnings;
#use strict;
use utf8;
use File::Basename;
use Data::Dumper qw(Dumper);
use List::Util qw( min max );

########                                    ##########
#                 MAIN PROGRAM                       #
########                                    ##########

# This function will open the input file and make an array of hashes 
# Access each node by $vertical[number] 
# Access the weight by $vertical[number]{'2'}

my $dir = "/Users/preciousbrazil/Desktop/Sandbox/in";
opendir(DIR, $dir) or die "Could not open $dir\n";

#go through all the files within the input folder
foreach my $file (glob("$dir/*")) {

   #apply algorithm to the first file for test
   open my $filename, "<", $file or die "can't open '$file'\n";
   #create an array that will number of edges and nodes
   my @numNodes = (); 
   @numEdges = ();
   my @horizontal = ();
   my @vertical = ();
   my $lineNum=0;
   
   print "Reading input file $file . . \n";
   my $j = 0;
   while(my $line = <$filename>){
         my $array_ref = +{};
         $filebasename = basename($file);
         $outputname = ($filebasename =~ m/.+?(?=.)/);
         $lineNum +=1;
         chomp $line;
         #first line
         if ($lineNum == 1){
               @numNodes = split (/ /, $line);
         }
         #second line
         elsif ($lineNum ==2){
               @numEdges = split (/ /, $line);
         }
         #body
         else {
         #create array of arrays
         my @fields = split / /, $line; 
    
            foreach my $i (0..2){
                  $horizontal[$i] = $fields[$i];
                  $array_ref -> {$i} = $horizontal[$i];                 
            }

         push @vertical, $array_ref;

         $j += 1;
        #print "Line finished reading\n";    
        
        } #close reading body statement   
    
   } #close while open

  #Checking values
  #print Dumper (@numNodes);
  #print Dumper (@numEdges);
  print "*********** Printing the expected 2x2 array\n";
  print Dumper (@vertical);
      
   #Let me know when EOF is reached
   print "File Ended.. Opening next file..\n";
   close($filename);
   
   # Assign the nodes to a partition 
   my $partition_assign = $numEdges[1]/2;
   #print "Partition assignment $partition_assign \n";
   
   # Start of the randomized partiiton
   my @partition0 = map {0} (1.. $numEdges[1]/2);
   my @partition1 = map {1} (1.. $numEdges[1]/2);
   #combine the partition vector list
   push @partition0, @partition1;
   #randomize the partition assignment
   @partition = sort { (-1, 1) [rand(2)] } @partition0;
   print "The original partition......\n";
   print Dumper (@partition);
   
   #Create a partition for testing purpose only, comment after it works
   #@partition = ("1", "0", "0", "0", "1", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "0"); 
   
   #Create a new array for partition status, start with everything unlocked
   @gain= map {0} (1.. $numEdges[1]);
   $counter = 0;
   #to check if locked/unlocked use $status[$counter]
   
   #Create a new array for partition status, start with everything unlocked
   #status 0 = unlocked, status 1 = locked
   @status= map {0} (1.. $numEdges[1]);
   #print "The original status......\n";
   #print Dumper (@status);
   
 
   $initialCut = &computeCutSet(\@vertical, \@partition);
   print "The value of the initial cut in the main program: $initialCut\n";

 while ($counter != $numEdges[1]) {
 
   print "***  Swapping nodes...... \n";
   &swapNodes(\@partition);
   #print "Printing the swapped partition in the main function...... \n";
   #print Dumper (@partition);
  		
   # calculate the new cutset only when swap occurred 
   $newCut = &computeCutSet(\@vertical, \@partition);
   print "The value of the cutsize after swapping nodes: $newCut \n";

   $gain[$counter] = $initialCut - $newCut;
   print "The gain of the swap is: $gain[$counter] \n";

	$counter += 1;
	print "counter: $counter\n";
	}

  print "**** Printing gain array \n";
  print Dumper (@gain); 
  
  
  ##TODO: Keep the swap that has gotten the greater gain
  
  ##TODO: Swap the items in the actual data array
  
  ##TODO: Create the Output file based on the swap
  ##TODO: send the new partition to write Output
    my $max = max @gain;
    open my $output, '>', '0'.$outputname.'.out';
    print {$output} "cut $max" . "\n";
    print {$output} "Partition assignment here " . "\n";
    print {$output} "Parition assignment here" . "\n";
    close $output;
  
  print "\n\n*************************************************************\n\n";
  exit; #only do the first file for now


}

closedir(DIR);

########                                    ##########
#                   SUBROUTINES                      #
########                                    ##########

sub computeCutSet {

   # Compute the cut
   my ($vertical, $partition) = @_;
   my $cutSize = 0;
   my @vertical = @{$vertical};
   my @partition = @{$partition};
 
   print "The partition we are calculating the cutset is.... \n";
   print Dumper (@partition);  

   foreach my $item(@vertical){
	if ($partition[$item->{'0'}-1] != $partition[$item->{'1'}-1]){
            $cutSize += $item->{'2'};
	}  
   }
   #print "The final value of the initial cut is: $initialCut\n";
   return $cutSize;
}

sub swapNodes {
  #actually getting an array reference to the original partition array
  my $partition = @{$_[0]};	
  print "Printing the partition array received in the subroutine\n";
  print Dumper (@partition);

   for (my $i=0; $i<=$#partition; $i+=1){
   print "Printing the value of i : $i \n";
        # check the status of the partition we are checking
        # if both 0, meaning unlocked so continue
        # if both 1, meaning locked so move on to the next two
        
        #print "status0 $status[$i] and status1 $status[$i+1]\n";
        if (($status[$i] | $status[$i+1]) == 1){
        print "Exiting status check and not swapping\n";
        #go to the next item in the foreach
        goto EXIT; 
        }
        
     	# compare the two nodes connected if they are in the same partition  	
  		if ($partition[$i] != $partition[$i+1]){
  			print "Enter partition swapping \n";
  		    #not in the same partition, swap
			($partition[$i], $partition[$i+1]) = ($partition[$i+1], $partition[$i]);
			($status[$i], $status[$i+1]) = (1, 1);

			last;	
  	      } 
  	      
  	EXIT:
  	#print "about to go back to the top of for loop\n";	
  }
#print "Printing swapped partition in the subroutine\n";
#print Dumper (@partition);
}


