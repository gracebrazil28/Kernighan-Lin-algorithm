#! /usr/bin/perl
use warnings;
#use strict;
use utf8;
use File::Basename;
use Data::Dumper qw(Dumper);

########                                    ##########
#                 MAIN PROGRAM                       #
########                                    ##########

# This function will open the input file and make an array of hashes 
# Access each node by $vertical[number] 
# Access the weight by $vertical[number]{'2'}

my $dir = "/Users/preciousbrazil/Desktop/Sandbox/in";
opendir(DIR, $dir) or die "Could not open $dir\n";
#my @files = grep {-f $_ } glob ("$dir");


#go through all the files within the input folder
foreach my $file (glob("$dir/*")) {

   #apply algorithm to the first file for test
   open my $filename, "<", $file or die "can't open '$file'\n";
   #create an array that will number of edges and nodes
   my @numNodes = (); 
   my @numEdges = ();
   my @horizontal = ();
   my @vertical = ();
   my $lineNum=0;
   
   print "Reading input file $file . . \n";
   my $j = 0;
   while(my $line = <$filename>){
         my $array_ref = +{};
         my $filebasename = basename($filename);
        
         $lineNum +=1;
         chomp $line;
         #first line
         if ($lineNum == 1){
               @numNodes = split (/ /, $line);
         }
         #second line
         elsif ($lineNum ==2){
               @numEdges = split (/ /, $line);
         }
         #body
         else {
         #create array of arrays
         my @fields = split / /, $line; 
    
            foreach my $i (0..2){
                  $horizontal[$i] = $fields[$i];
                  $array_ref -> {$i} = $horizontal[$i];
                 #Trying to extending this to labeling them with the input filename
                 #$array_ref->{ $filename }{$i} = $horizontal[$i];
                 #$array_ref->{ $filebasename }{$i} = $horizontal[$i];
                #$array_ref -> {partition} = int rand(2);
                 
            }

         push @vertical, $array_ref;

         $j += 1;
        #print "Line finished reading\n";    
        
        } #close reading body statement   
    
   } #close while open


  #Checking values
  #print Dumper (@numNodes);
  #print Dumper (@numEdges);
  #print "3rd column 6th row $vertical[5]{ $filename }{'2'}\n";
  #print "Look at partition $vertical[5]{partition}\n";
  #print "*********** Printing the expected 2x2 array\n";
   print Dumper (@vertical);
      
   #Let me know when EOF is reached
   print "File Ended.. Opening next file..\n";
   close($filename);
   
   # Assign the nodes to a partition 
   my $partition_assign = $numEdges[1]/2;
   #print "Partition assignment $partition_assign \n";
   
   my @partition0 = map {0} (1.. $numEdges[1]/2);
   my @partition1 = map {1} (1.. $numEdges[1]/2);
   #combine the partition vector list
   push @partition0, @partition1;
   #randomize the partition assignment
   @partition = sort { (-1, 1) [rand(2)] } @partition0;
   print Dumper (@partition);
   
 
   $initialCut = &computeCutSet(\@vertical, \@partition);
   print "The value of the initial cut in the main program: $initialCut\n";
 	 
   print "Swapping nodes...... \n";
   &swapNodes(\@partition);
   print Dumper (@partition);
  		
   # calculate the new cutset
   $newCut = &computeCutSet(\@vertical, \@partition);
   print "The value of the cutsize after swapping nodes: $newCut \n";

   $gain = $newCut - $initialCut;
   print "The gain of the swap is: $gain \n";
 
  exit; #only do the first file for now
}

closedir(DIR);

########                                    ##########
#                   SUBROUTINES                      #
########                                    ##########

sub computeCutSet {

   # Compute the cut
   my ($vertical, $partition) = @_;
   my $cutSize = 0;
   my @vertical = @{$vertical};
   my @partition = @{$partition};
   
   foreach my $item(@vertical){
   # compare the two nodes connected if they are in the same partition
	if ($partition[$item->{'0'}] != $partition[$item->{'1'}]) {
            $cutSize += $item->{'2'};
            #print "The cut has increased to: $initialCut \n";
	}  
    
    
   }
   #print "The final value of the initial cut is: $initialCut\n";
   return $cutSize;
}

sub swapNodes {
  my $partition = shift;
  shift (@$partition);
  foreach my $item (@partition){
  		if ($partition[$item] != $partition[$item+1]){
  		    ($partition[$item], $partition[$item+1]) = ($partition[$item+1], $partition[$item])
  		}
  }
  		
#print "Printing swapped partition in the subroutine\n";
#print Dumper (@partition);
}

sub computeNewCutSet {

   my ($vertical, $partition) = @_;
   my $newCut = 0;
   my @vertical = @{$vertical};
   my @partition = @{$partition}; 
   foreach my $item(@vertical){
      #compare the two nodes connected if they are in the same partition
	if ($partition[$item->{'0'}] != $partition[$item->{'1'}]) {
            $newCut += $item->{'2'};
	} 
	 
   }

	return $newcut;
}
